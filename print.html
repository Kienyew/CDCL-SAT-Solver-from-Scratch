<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>CDCL From Scratch in Python</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="CDCL-SAT-Solver-from-Scratch.html">CDCL SAT Solver from Scratch</a></li><li class="chapter-item expanded "><a href="The-Theory.html"><strong aria-hidden="true">1.</strong> The Theory</a></li><li class="chapter-item expanded "><a href="The-Implementation.html"><strong aria-hidden="true">2.</strong> The Implementation</a></li><li class="chapter-item expanded "><a href="Two-Watched-Literals.html"><strong aria-hidden="true">3.</strong> Advanced: Two-Watched Literals</a></li><li class="chapter-item expanded "><a href="Conclusion.html"><strong aria-hidden="true">4.</strong> Conclusion</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">CDCL From Scratch in Python</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="cdcl-sat-solver-from-scratch"><a class="header" href="#cdcl-sat-solver-from-scratch">CDCL SAT Solver from Scratch</a></h1>
<p>CDCL refers to <strong>[Conflict-Driven-Clause-Learning]</strong>.</p>
<p>I hardly found any tutorial about how to implement a complete CDCL SAT solver with two-watched literals, to save someone, I decided to write one implementation of CDCL SAT solver, not the most efficient, but hopefully a submittable assignment.</p>
<p>I highly recommend you to refer <a href="https://users.aalto.fi/~tjunttil/2020-DP-AUT/notes-sat/cdcl.html">this website</a> with or without much understanding about how CDCL works. </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-theory"><a class="header" href="#the-theory">The Theory</a></h1>
<ul>
<li>Everything in this section is taken from <a href="https://www.cs.princeton.edu/~zkincaid/courses/fall18/readings/SATHandbook-CDCL.pdf">Handbook of Satisfiability Chapter 4: Conflict-Driven Clause Learning SAT Solvers</a>.</li>
</ul>
<p>CDCL SAT solvers primarily inspired by DPLL solvers. DPLL corresponds to <strong>backtrack search</strong>, where each step a variable and a propositional value are selected for branching purposes. With each branching step, two values can be assigned to a variable: 0 or 1. Branching corresponds to assign the chosen value to the chosen variable. Afterwards, the logical consequences of each branching step are evaluated. Each time an unsatisfied clause (conflict) is identified, <strong>backtracking</strong> is executed.</p>
<p>If for the first branching step, both values have been considered, and backtracking undoes this first branching step, then the CNF formula can be declared <strong>unsatisfiable</strong>. This kind of backtrack is called <strong>chronological backtracking</strong>. Alternative backtracking scheme is <strong>non-chronological backtracking</strong>, which described later.</p>
<p>A state-of-art CDCL SAT solver involves a number of key techniques:</p>
<ul>
<li>Learning new clause from conflicts during backtrack search.</li>
<li>Exploiting structure of conflicts during clause learning.</li>
<li>Branching and restart heuristics.</li>
</ul>
<p>I won't cover branching and restart heuristic here. They can be added to the code space relatively easily.</p>
<h2 id="1-notation"><a class="header" href="#1-notation">1. Notation</a></h2>
<p>Propositional formulas are represented in Conjunctive Normal form (CNF).</p>
<ul>
<li>A finite set of Boolean variables \(X=\{x_1,x_2,\cdots,x_n\}\) is assumed.</li>
<li>We use \(w\) to denote a clause.</li>
<li>We use \(\phi\) to denote a CNF formula, consists of a conjunction of clauses.</li>
<li>A literal \(l\) is either a variable \(x\) or its complement \(¬ x\).</li>
</ul>
<h4 id="assignments"><a class="header" href="#assignments">Assignments</a></h4>
<p>Assignments to the problem variables can be defined as a function \(\nu:X\to\{0,u,1\}\) where \(u\) denotes an <strong>undefined</strong> value.</p>
<ul>
<li>If all variables are assigned a value \(\{0,1\}\), then \(\nu\) is referred to as a <strong>complete assignment</strong>, otherwise it is a partial assignment.</li>
<li>\(l^\nu\) denotes the value of a literal \(l\) under assignment \(\nu\).</li>
<li>\(w^\nu\) denotes the value of a clause \(w\) under assignment \(\nu\).</li>
<li>\(\phi^\nu\) denotes the value of the formula \(\phi\) under assignment \(\nu\).</li>
</ul>
<p>\[
\begin{align}
l^\nu &amp;= \begin{cases}
\nu(x_i),&amp;l=x_i \\
1-\nu(x_i),&amp;l=¬ x_i
\end{cases} \\
w^\nu &amp;= \max\{l^\nu | l\in w\} \\
\phi^\nu &amp;= \min\{w^\nu | w\in\phi\}
\end{align}
\]</p>
<h4 id="clauses"><a class="header" href="#clauses">Clauses</a></h4>
<p>Clauses are characterized as <strong>unsatisfied</strong>, <strong>satisfied</strong>, <strong>unit</strong>, or <strong>unresolved</strong>.</p>
<ul>
<li>A clause is <strong>unsatisfied</strong> if all its literals are assigned to value 0 under the assignment.</li>
<li>A clause is <strong>unit</strong> if all literals but one are assigned value 0, and the one literal are unassigned.</li>
<li>A clause is <strong>satisfied</strong> if at least one of its literal is assigned to value 1.</li>
<li>A clause is <strong>unresolved</strong> if neither falls in satisfied, unsatisfied or unit.</li>
</ul>
<p>A key procedure in SAT solvers is the <strong>unit clause rule</strong>: if a clause is unit, then its sole unassigned literal must be assigned to value 1. The iterated application of unit clause rule is referred to as <strong>unit propagation</strong> or <strong>Boolean constraint propagation (BCP)</strong>.</p>
<p>Unit propagation is applied after each branching step, and is used for identifying variables which must be assigned a specific Boolean value. If an unsatisfied clause is identified, a <strong>conflict</strong> condition is declared, and the algorithm backtracks.</p>
<h4 id="value-antecedent-and-decision-level"><a class="header" href="#value-antecedent-and-decision-level">Value, Antecedent and Decision Level</a></h4>
<p>Each variable \(x_i\) is characterized by a number of properties, including the <strong>value</strong>, <strong>antecedent</strong> and the <strong>decision level</strong> of it.</p>
<p>The <strong>value</strong> of \(x_i\) is the assigned value of it given the assignment</p>
<p>\[
\nu(x_i) \in \{0,u,1\}
\]</p>
<p>where 0 = False, 1 = True, \(u\) = Unassigned.</p>
<p>The <strong>antecedent</strong> of \(x_i\) is the unit clause \(w\) that implies it. For unassigned variables, or variables that are assigned by decision, then their antecedent is \(\tt NIL\).</p>
<p>$$
\alpha(x_i) \in \phi \cup\{\tt{NIL}\}
$$</p>
<p>The <strong>decision level</strong> for a variable \(x_i\) denotes the depth of the decision tree at which the variable is assigned a value in \(\{0,1\}\). The decision level for an unassigned value \(x_i\) is \(-1\).</p>
<p>$$
\delta(x_i) = \max(\{0\}\cup \{\delta(x_j) \mid x_j \in w ∧ x_j \ne x_i\})
$$</p>
<p>The formula above says that the decision level of an implied literal is either the highest decision level of the implied literals in a unit clause, or \(0\) if the clause is unit.</p>
<p>We use \(x_i = v@d\) to denote that \(\nu(x_i) = v\) and \(\delta(x_i = d)\).</p>
<h4 id="implication-graph"><a class="header" href="#implication-graph">Implication Graph</a></h4>
<p>During the execution of DPLL-style SAT solver, assigned variables as well as their antecedents define a directed acyclic graph \(I=(V_I,E_I)\) referred to as <strong>implication graph</strong>.</p>
<p>The vertices in the implication graph are defined by all assigned variables and possibly one special node \(\kappa\) - the conflict node. The edges in the implication graph are obtained from the antecedent of each assigned variable. If \(w=\alpha(x_i)\), then there is a directed edge from each variable in \(w\) (other than \(x_i\) to \(x_i\).</p>
<p>If unit propagation yields an unsatisfied clause \(w_j\), then a special vertex \(\kappa\) is used to represent the unsatisfied clause. The antecedent of \(\kappa\) is defined by \(\alpha(\kappa) = w_j\).</p>
<p><strong>Example</strong>:</p>
<p>Consider the CNF:</p>
<p>\[
\begin{align}
\phi_i &amp;= w_1∧ w_2 ∧ w_3 \\
&amp;= (x_1 ∨ x_{31} ∨ ¬ x_2) ∧ (x_1 ∨ ¬ x_3) ∧ (x_2 ∨ x_3 ∨ x_4)
\end{align}
\]</p>
<p>and assume the decision assignment \(x_{31}=0@3\) and \(x_1 = 0@5\), then their implication graph is:</p>
<p><img src="./images/image-20221224153730404.png" alt="image-20221224153730404" /></p>
<h2 id="2-organization-of-cdcl-solvers"><a class="header" href="#2-organization-of-cdcl-solvers">2. Organization of CDCL Solvers</a></h2>
<p>The figure shows the typical algorithm for CDCL:</p>
<p><img src="./images/image-20221224154721848.png" alt="image-20221224154721848" /></p>
<p>The main differences to DPLL solver is the call to function \(\tt ConflictAnalysis\) each time a conflict is identified, and a call to \(\tt BackTrack\) when backtracking takes place.</p>
<ul>
<li>\(\tt UnitPropagation\) consists of the iterated application of the unit clause rule. If an unsatisfied clause is identified, then a conflict indication is returned.</li>
<li>\(\tt PickBranchingValue\) selects a variable to assign a value.</li>
<li>\(\tt ConflictAnalysis\) analyzes the most recent conflict and learn a new clause from the conflict.</li>
<li>\(\tt AllVariablesAssigned\) tests whether all variables have been assigned.</li>
</ul>
<p>Some techniques like <strong>search restarts</strong> and <strong>clause deletion</strong> are not included in the algorithm above.</p>
<ul>
<li><strong>Search restarts</strong> cause the algorithm to restart itself, but already learnt clauses are kept.</li>
<li><strong>Clause deletion</strong> policies decide which learnt clauses can be deleted to saves memory.</li>
</ul>
<h2 id="3-conflict-analysis"><a class="header" href="#3-conflict-analysis">3. Conflict Analysis</a></h2>
<h3 id="learning-clauses-from-conflicts"><a class="header" href="#learning-clauses-from-conflicts">Learning Clauses from Conflicts</a></h3>
<p>Each time the CDCL SAT solver identifies a conflict due to unit propagation, the \(\tt ConflictAnalysis\) procedure is invoked. One or more new clauses are learnt, and a backtracking decision level is computed.</p>
<p>Starting from a given conflict clause \(\alpha(\kappa)\), the conflict analysis procedure visits variables implied at the most recent decision level, identifies the antecedents of visited variables, and keeps from the antecedents of literals assigned at decision level <strong>less than the most recent decision level</strong>. This process is repeated until the most recent decision variable is visited.</p>
<p>Let \(\odot\) be the resolution operation. The resolution operation on two clause \(w_i\) and \(w_j\), for which there is a variable that \(x\) in one clause and \(¬ x\) in another clause, then the result of the resolution operation is all literals in \(w_i\) and \(w_j\) with the exception of \(x\) and \(¬ x\):</p>
<p>$$
w_i \odot w_j = w_i \cup w_j - \{x,¬ x\}
$$</p>
<p>Now we show how the new clause is learnt. The clause learning process in SAT solvers can be defined by a sequence of selective resolution operations. At each step, it yields a new temporary clause, and the final clause is the newly learnt clause.</p>
<p>First, we define a predicate \(\xi(w,l,d)\) which means if a clause \(w\) has an implied literal \(l\) assigned at the current decision level \(d\).</p>
<p>\[
\xi(w,l,d) = \begin{cases}
1,&amp;l\in w ∧ \delta (l) =d ∧ \alpha(l) \ne \tt NIL \\
0,&amp;\text {otherwise}
\end{cases}
\]</p>
<p>Let \(w_L^{d,i}\) with \(i=0,1,\cdots\) be the <strong>intermediate clause</strong> obtained after \(i\) resolution operations.</p>
<p>\[
w_L^{d,i} = \begin{cases}
\alpha(\kappa),&amp;i=0 \\
w_L^{d,i-1} \odot \alpha(l).&amp;i\ne 0 ∧ \xi(w_L^{d,i-1},l,d) = 1 \\
w_L^{d,i-1},&amp; i\ne 0 ∧ \forall _l \xi(w_L^{d,i-1},l,d)=0
\end{cases}
\]</p>
<p>The explanation of \(w_L^{d,i}\):</p>
<ul>
<li>The initial intermediate clause is the antecedent of \(\kappa\), \(\alpha(\kappa)\).</li>
<li>Afterwards, at each step \(i\), a literal \(l\) assigned at the current decision level \(d\) is selected from the current intermediate clause, the next intermediate clause \(w_{L}^{d,i}\) is the result of resolution between the current intermediate clause:</li>
</ul>
<p>$$
w_L^{d,i} = w_L^{d,i-1} \odot \alpha(l)
$$</p>
<ul>
<li>This continues until there left no literal in current intermediate clause with current decision level \(d\), or</li>
</ul>
<p>$$
w_L^{d,i} = w_L^{d,i-1}
$$</p>
<p>The last intermediate clause is the new learnt clause. The number of resolutions performed will not greater than number of variables \(|X|\).</p>
<p><strong>Example</strong>: Given the formula, with the implication graph</p>
<p>\[
\begin{align}
\phi &amp;= w_1 ∧ w_2 ∧ w_3 ∧ w_4 ∧ w_5 ∧ w_6 \\
&amp;= (x_1 ∨ x_{31} ∨ ¬ x_2) ∧ (x_1 ∨ ¬ x_3) ∧ (x_2 ∨ x_3 ∨ x_3) \\
&amp;~~~~~(¬ x_4 ∧ ¬ x_5) ∧ (x_{21} ∨ ¬ x_4 ∨ ¬ x_6) ∧ (x_5 ∨ x_6)
\end{align}
\]</p>
<p><img src="./images/image-20221224172134735.png" alt="image-20221224172134735" /></p>
<p>The table shows the resolution steps during clause learning.</p>
<img src="./images/image-20221224172210628.png" alt="image-20221224172210628" style="zoom: 67%;" />
<p>There are many possible clauses to learn on one conflict. The learnt clause of method above is just the negation of literals of most recent decision level. However, we usually learn a new exploit the first UIP cut, explained in the next section:</p>
<h3 id="exploiting-structure-with-uips"><a class="header" href="#exploiting-structure-with-uips">Exploiting Structure with UIPs</a></h3>
<p>A vertex \(u\) dominates another vertex \(x\) in a directed graph if every path from \(x\) to another vertex \(\kappa\) contains \(u\). A UIP (unique implication point) is a <strong>dominator</strong> in the implication graph, which dominates the decision vertex \(x\) with respect to the conflict vertex \(\kappa\).</p>
<p>In the implication graph, there is an UIP at decision level \(d\) when the number of literals in \(w_L^{d,i}\) assigned at decision level is 1. Let \(\sigma(w,d)\) be the number of literals in \(w\) assigned at decision level \(d\):</p>
<p>$$
\sigma(w,d) = |\{l \in w \mid \delta(l) = d\}|
$$</p>
<p>The clause learning procedure with UIPs is given by</p>
<p>\[
w_L^{d,i} = \begin{cases}
\alpha(\kappa),&amp;i=0 \\
w_L^{d,i-1} \odot \alpha(l).&amp;i\ne 0 ∧ \xi(w_L^{d,i-1},l,d) = 1 \\
w_L^{d,i-1},&amp; i\ne 0 ∧ \sigma(w_L^{d,i-1},d) = 1
\end{cases}
\]</p>
<p>CDCL SAT solvers stop clause learning at the first UIP.</p>
<p><strong>Example</strong>: Again with the previous example</p>
<p>\[
\begin{align}
\phi &amp;= w_1 ∧ w_2 ∧ w_3 ∧ w_4 ∧ w_5 ∧ w_6 \\
&amp;= (x_1 ∨ x_{31} ∨ ¬ x_2) ∧ (x_1 ∨ ¬ x_3) ∧ (x_2 ∨ x_3 ∨ x_3) \\
&amp;~~~~~(¬ x_4 ∧ ¬ x_5) ∧ (x_{21} ∨ ¬ x_4 ∨ ¬ x_6) ∧ (x_5 ∨ x_6)
\end{align}
\]</p>
<p><img src="./images/image-20221224172134735.png" alt="image-20221224172134735" /></p>
<p>The learning procedure stops at \((¬ x_4 ∨ x_{21})\) by taking into consideration that \(x_4=1@5\) is a UIP - the first UIP.</p>
<img src="./images/image-20221224174926922-16743682034371.png" alt="image-20221224174926922" style="zoom:67%;" />
<p>Finally, we start the code in next section.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-implementation"><a class="header" href="#the-implementation">The Implementation</a></h1>
<p>In the code, I frequently use the <a href="https://docs.python.org/3/library/dataclasses.html">dataclass</a> from standard library. Basically it is just a shorthand for defining a small class storing only few properties. It saves the code for us to define <code>__init__</code> function, and better default string representation:</p>
<pre><code class="language-python">from dataclasses import dataclass

@dataclass
class Animal:
    name: str
    kind: str
    age: int

print(Animal('Pikachu', 'Cat', 3))  
# output: Animal(name='Pikachu', kind='Cat', age=3)
</code></pre>
<p>It becomes clear on what a class stores.</p>
<h2 id="structures"><a class="header" href="#structures">Structures</a></h2>
<p>Next, we implement the class for</p>
<ul>
<li>Literal = <code>var + negation?</code></li>
<li>Clause = <code>List[Literal]</code></li>
<li>Formula = <code>List[Clause]</code></li>
</ul>
<p>Instead of representing them with primitive types, put them into individual classes are easier to read in my opinion.</p>
<p>The variables are represented as integer. First import all the standard libraries we used:</p>
<pre><code class="language-python">import sys
import random
from pprint import pprint
from dataclasses import dataclass
from typing import List, Set, Tuple, Optional, Iterator
</code></pre>
<h3 id="literal"><a class="header" href="#literal">Literal</a></h3>
<pre><code class="language-python"># frozen to be hashable
@dataclass(frozen=True)
class Literal:
    variable: int
    negation: bool

    def __repr__(self):
        if self.negation:
            return '¬' + str(self.variable)
        else:
            return str(self.variable)

	def neg(self) -&gt; 'Literal':
        &quot;&quot;&quot;
        Return the negation of this literal.
        &quot;&quot;&quot;
        return Literal(self.variable, not self.negation)
</code></pre>
<h3 id="clause"><a class="header" href="#clause">Clause</a></h3>
<p>The clause is just a list of literals.</p>
<pre><code class="language-python">@dataclass
class Clause:
    literals: List[Literal]

    def __repr__(self):
        return '∨'.join(map(str, self.literals))

    def __iter__(self) -&gt; Iterator[Literal]:
        return iter(self.literals)

    def __len__(self):
        return len(self.literals)
</code></pre>
<h3 id="formula"><a class="header" href="#formula">Formula</a></h3>
<p>The formula is just a list of clauses. We remove duplicate literals like \((1∨ 1 ∨ 2)\) and cache the variables in the constructor.</p>
<pre><code class="language-python">@dataclass
class Formula:
    clauses: List[Clause]
    __variables: Set[int]

    def __init__(self, clauses: List[Clause]):
        &quot;&quot;&quot;
        Remove duplicate literals in clauses.
        &quot;&quot;&quot;
        self.clauses = []
        self.__variables = set()
        for clause in clauses:
            self.clauses.append(Clause(list(set(clause))))
            for lit in clause:
                var = lit.variable
                self.__variables.add(var)

    def variables(self) -&gt; Set[int]:
        &quot;&quot;&quot;
        Return the set of variables contained in this formula.
        &quot;&quot;&quot;
        return self.__variables

    def __repr__(self):
        return ' ∧ '.join(f'({clause})' for clause in self.clauses)

    def __iter__(self) -&gt; Iterator[Clause]:
        return iter(self.clauses)

    def __len__(self):
        return len(self.clauses)
</code></pre>
<h3 id="assignment"><a class="header" href="#assignment">Assignment</a></h3>
<p><code>Assignment</code> class represent one assignment to a variable. It contains</p>
<ul>
<li>The value (<code>True</code> or <code>False</code>) of what the variable assigned to.</li>
<li>The optional antecedent of this assignment. The antecedent is the clause that forced this assignment due to unit constraint. If this assignment is due to decision (guessing), then antecedent is <code>None</code>.</li>
<li><code>dl</code> - The decision level of this assignment.</li>
</ul>
<pre><code class="language-python">@dataclass
class Assignment:
    value: bool
    antecedent: Optional[Clause]
    dl: int  # decision level
</code></pre>
<img src="./images/image-20230122150424569.png" alt="image-20230122150424569" style="zoom: 67%;" />
<p>An instance of <code>Assignment</code> contains the information in the red circle.</p>
<ul>
<li><code>value</code> = 0 (False)</li>
<li><code>antecedent</code> = \(\omega_2\)</li>
<li><code>dl</code> = 5</li>
</ul>
<h3 id="assignments-1"><a class="header" href="#assignments-1">Assignments</a></h3>
<p><code>Assignments</code> is the partial assignments of variables, maps an <code>int</code> to <code>Assignment</code>. An efficient representation of assignments should be stored in a list trail, which improve the backtrack efficiency.</p>
<p>I also added a utility method <code>value</code> here.</p>
<pre><code class="language-python">class Assignments(dict):
    &quot;&quot;&quot;
    The assignments, also stores the current decision level.
    &quot;&quot;&quot;
    def __init__(self):
        super().__init__()

        # the decision level
        self.dl = 0

    def value(self, literal: Literal) -&gt; bool:
        &quot;&quot;&quot;
        Return the value of the literal with respect the current assignments.
        &quot;&quot;&quot;
        if literal.negation:
            return not self[literal.variable].value
        else:
            return self[literal.variable].value

    def assign(self, variable: int, value: bool, antecedent: Optional[Clause]):
        self[variable] = Assignment(value, antecedent, self.dl)

    def unassign(self, variable: int):
        self.pop(variable)

    def satisfy(self, formula: Formula) -&gt; bool:
        &quot;&quot;&quot;
        Check whether the assignments actually satisfies the formula. 
        &quot;&quot;&quot;
        for clause in formula:
            if True not in [self.value(lit) for lit in clause]:
                return False

        return True
</code></pre>
<h2 id="main-procedures"><a class="header" href="#main-procedures">Main Procedures</a></h2>
<p>Having defined all the needed classes, now are the hard parts. We will implement the full CDCL solver here.</p>
<p>The CDCL algorithm generally follows the structure:</p>
<p><img src="./images/image-20230123195153774.png" alt="image-20230123195153774" />Note that \(\nu\) above is the partial assignments, which represented by <code>assignments</code> in our code.</p>
<p>Translate it into Python code:</p>
<h3 id="cdcl_solve"><a class="header" href="#cdcl_solve"><code>cdcl_solve</code></a></h3>
<p>We return the <code>learnt_clause</code> from <code>conflict_analysis</code>, and add the <code>learnt_clause</code> to the formula afterward, and return the reason as well as the clause that are the cause of the reason from <code>unit_propagation</code>.</p>
<pre><code class="language-python">def cdcl_solve(formula: Formula) -&gt; Optional[Assignments]:
    &quot;&quot;&quot;
    Solve the CNF formula.

    If SAT, return the assignments.
    If UNSAT, return None.
    &quot;&quot;&quot;
    assignments = Assignments()
    
    # First, do unit propagation to assign the initial unit clauses 
    reason, clause = unit_propagation(formula, assignments)
    if reason == 'conflict':
        return None

    while not all_variables_assigned(formula, assignments):
        var, val = pick_branching_variable(formula, assignments)
        assignments.dl += 1
        assignments.assign(var, val, antecedent=None)
        while True:
            reason, clause = unit_propagation(formula, assignments)
            if reason != 'conflict':
                # no conflict after unit propagation, we back
                # to the decision (guessing) step
                break
                
            b, learnt_clause = conflict_analysis(clause, assignments)
            if b &lt; 0:
                return None
            
            add_learnt_clause(formula, learnt_clause)
            backtrack(assignments, b)
            assignments.dl = b

            # The learnt clause must be a unit clause, so the
            # next step must again be unit progagation

    return assignments
</code></pre>
<p>Next, we implement all the functions mentioned in <code>cdcl_solve</code>. Starts from the easy to hard.</p>
<h3 id="add_learnt_clause"><a class="header" href="#add_learnt_clause"><code>add_learnt_clause</code></a></h3>
<p>&quot;Learning&quot; a clause is just as simple as adding it to the formula.</p>
<pre><code class="language-python">def add_learnt_clause(formula: Formula, clause: Clause):
    formula.clauses.append(clause)
</code></pre>
<h3 id="all_variables_assigned"><a class="header" href="#all_variables_assigned"><code>all_variables_assigned</code></a></h3>
<p>As simple as it is:</p>
<pre><code class="language-python">def all_variables_assigned(formula: Formula, assignments: Assignments) -&gt; bool:
    return len(formula.variables()) == len(assignments)
</code></pre>
<h3 id="pick_branching_variable"><a class="header" href="#pick_branching_variable"><code>pick_branching_variable</code></a></h3>
<p>Choose the next decision variable and its value based on our branching heuristic - no heuristic.</p>
<p>We randomly choose a variable in unassigned variables and randomly choose a value.</p>
<pre><code class="language-python">def pick_branching_variable(formula: Formula, assignments: Assignments) -&gt; Tuple[int, bool]:
    unassigned_vars = [var for var in formula.variables() if var not in assignments]
    var = random.choice(unassigned_vars)
    val = random.choice([True, False])
    return (var, val)
</code></pre>
<h3 id="backtrack"><a class="header" href="#backtrack"><code>backtrack</code></a></h3>
<p>This function backtracks to decision level \(b\), removing all the assignment of variables with decision level \(\gt b\).</p>
<pre><code class="language-python">def backtrack(assignments: Assignments, b: int):
    to_remove = []
    for var, assignment in assignments.items():
        if assignment.dl &gt; b:
            to_remove.append(var)
            
	for var in to_remove:
        assignments.pop(var)
</code></pre>
<h3 id="unit_propagation"><a class="header" href="#unit_propagation"><code>unit_propagation</code></a></h3>
<p>Next is unit propagation. We detect conflict or unit clause in this function, and return the reason and the corresponding clause.</p>
<pre><code class="language-python">def clause_status(clause: Clause, assignments: Assignments) -&gt; str:
    &quot;&quot;&quot;
    Return the status of the clause with respect to the assignments.

    There are 4 possible status of a clause:
      1. Unit - All but one literal are assigned False
      2. Unsatisfied - All literals are assigned False
      3. Satisfied - All literals are assigned True
      4. Unresolved - Neither unit, satisfied nor unsatisfied
    &quot;&quot;&quot;
    values = []
    for literal in clause:
        if literal.variable not in assignments:
            values.append(None)
        else:
            values.append(assignments.value(literal))

    if True in values:
        return 'satisfied'
    elif values.count(False) == len(values):
        return 'unsatisfied'
    elif values.count(False) == len(values) - 1:
        return 'unit'
    else:
        return 'unresolved'


def unit_propagation(formula: Formula, assignments: Assignments) -&gt; Tuple[str, Optional[Clause]]:
    # finish is set to True if no unit and conflict clause found in one iteration
    finish = False
    while not finish:
        finish = True
        for clause in formula:
            status = clause_status(clause, assignments)
            if status == 'unresolved' or status == 'satisfied':
                continue
            elif status == 'unit':
                # select the literal to propagate
                literal = next(literal for literal in clause if literal.variable not in assignments)
                var = literal.variable
                val = not literal.negation

                # assign the variable according to unit rule
                assignments.assign(var, val, antecedent=clause)
                finish = False
            else:
                # conflict
                return ('conflict', clause)

    return ('unresolved', None)
</code></pre>
<h3 id="conflict_analysis"><a class="header" href="#conflict_analysis"><code>conflict_analysis</code></a></h3>
<p><code>conflict_analysis</code> finds the the backtrack level and the newly learnt clause, which comes from the first UIP cut.</p>
<p>It follows the formula (see the section above: <a href="The-Theory.html#exploiting-structure-with-uips">Exploiting Structure with UIPs</a>):
\[
w_L^{d,i} = \begin{cases}
\alpha(\kappa),&amp;i=0 \\
w_L^{d,i-1} \odot \alpha(l).&amp;i\ne 0 ∧ \xi(w_L^{d,i-1},l,d) = 1 \\
w_L^{d,i-1},&amp; i\ne 0 ∧ \sigma(w_L^{d,i-1},d) = 1
\end{cases}
\]
We first define the resolution operation, then the main <code>conflict_analysis</code> function:</p>
<pre><code class="language-python">def resolve(a: Clause, b: Clause, x: int) -&gt; Clause:
    &quot;&quot;&quot;
    The resolution operation
    &quot;&quot;&quot;
    result = set(a.literals + b.literals) - {Literal(x, True), Literal(x, False)}
    result = list(result)
    return Clause(result)


def conflict_analysis(clause: Clause, assignments: Assignments) -&gt; Tuple[int, Clause]:
    if assignments.dl == 0:
        return (-1, None)
 
    # literals with current decision level
    literals = [literal for literal in clause if assignments[literal.variable].dl == assignments.dl]
    while len(literals) != 1:
        # implied literals
        literals = filter(lambda lit: assignments[lit.variable].antecedent != None, literals)

        # select any literal that meets the criterion
        literal = next(literals)
        antecedent = assignments[literal.variable].antecedent
        clause = resolve(clause, antecedent, literal.variable)

        # literals with current decision level
        literals = [literal for literal in clause if assignments[literal.variable].dl == assignments.dl]

    # out of the loop, `clause` is now the new learnt clause
    # compute the backtrack level b (second largest decision level)
    decision_levels = sorted(set(assignments[literal.variable].dl for literal in clause))
    if len(decision_levels) &lt;= 1:
        return 0, clause
    else:
        return decision_levels[-2], clause
</code></pre>
<h3 id="dimacs-cnf"><a class="header" href="#dimacs-cnf">DIMACS CNF</a></h3>
<p>The <a href="https://people.sc.fsu.edu/~jburkardt/data/cnf/cnf.html">DIMACS CNF</a> format is a textual representation of a formula in conjunctive normal form.</p>
<p>For example, the formula \((1∨2∨¬ 3) ∧ (¬ 2 ∧ 3)\) can be encoded as:</p>
<pre><code>p cnf 3 2
1 2 -3 0
-2 3 0
</code></pre>
<h4 id="parse_dimacs_cnf"><a class="header" href="#parse_dimacs_cnf"><code>parse_dimacs_cnf</code></a></h4>
<p>Here is the code to parse DIMACS CNF file to a <code>Formula</code>, you can take it as given:</p>
<pre><code class="language-python">def parse_dimacs_cnf(content: str) -&gt; Formula:
    &quot;&quot;&quot;
    parse the DIMACS cnf file format into corresponding Formula.
    &quot;&quot;&quot;
    clauses = [Clause([])]
    for line in content.splitlines():
        tokens = line.split()
        if len(tokens) != 0 and tokens[0] not in (&quot;p&quot;, &quot;c&quot;):
            for tok in tokens:
                lit = int(tok)
                if lit == 0:
                    clauses.append(Clause([]))
                else:
                    var = abs(lit)
                    neg = lit &lt; 0
                    clauses[-1].literals.append(Literal(var, neg))

    if len(clauses[-1]) == 0:
        clauses.pop()

    return Formula(clauses)
</code></pre>
<p>and we have just successfully implemented a CDCL solver in less than 300 lines of code, try it out:</p>
<pre><code class="language-python">if __name__ == '__main__':
    # you might comment it to get inconsistent execution time
    random.seed(5201314)

    if len(sys.argv) != 2:
        print('Provide one DIMACS cnf filename as argument.')
        sys.exit(1)
        
    dimacs_cnf = open(sys.argv[1]).read()
    formula = parse_dimacs_cnf(dimacs_cnf)
    result = cdcl_solve(formula)
    if result:
        assert result.satisfy(formula)
        print('Formula is SAT with assignments:')
        assignments = {var: assignment.value for var, assignment in result.items()}
        pprint(assignments)
    else:
        print('Formula is UNSAT.')
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advanced-two-watched-literals"><a class="header" href="#advanced-two-watched-literals">Advanced: Two Watched Literals</a></h1>
<p>In my experience, implementing the original CDCL algorithm is not the hard part. Most of the complexity and debug time lies on the lazy data structures - two watched literals.</p>
<p>You must read the two-watched literals section in the slide <a href="https://www.cs.upc.edu/~oliveras/LAI/cdcl.pdf">From DPLL to CDCL SAT solvers</a> to understand the steps of two watched literals.</p>
<p>The main idea of two watched literals is: <strong>A clause with 2 non-false literals cannot be unit or conflicting</strong>.</p>
<p>In the following sections, we will modify our code to incorporate the two watched literals data structure in our CDCL solver.</p>
<h2 id="implementation"><a class="header" href="#implementation">Implementation</a></h2>
<p>First, we initialize the core data structure <code>lit2clauses</code> and <code>clause2lits</code>, where</p>
<ul>
<li><code>lit2clauses[lit]</code> are the clauses that are watching literal <code>lit</code> now.</li>
<li><code>clause2lits[c]</code> are the literals that clause <code>c</code> are watching now. If <code>c</code> is unit clause, <code>len(clause2lits[c]) == 1</code> or else <code>len(clause2lits[c]) == 2</code>.</li>
</ul>
<pre><code class="language-python">from collections import defaultdict
def init_watches(formula: Formula):
    &quot;&quot;&quot;
    Return lit2clauses and clause2lits
    &quot;&quot;&quot;
    
    lit2clauses = defaultdict(list)
    clause2lits = defaultdict(list)
    
    for clause in formula:
        if len(clause) == 1:
            # For unit clause, we watch the only literal
            lit2clauses[clause.literals[0]].append(clause)
            clause2lits[clause].append(clause.literals[0])
        else:
            # For other clause, we choose any 2 literals to watch
            lit2clauses[clause.literals[0]].append(clause)
            lit2clauses[clause.literals[1]].append(clause)
            clause2lits[clause].append(clause.literals[0])
            clause2lits[clause].append(clause.literals[1])
            
    return lit2clauses, clause2lits
</code></pre>
<p>We also add <code>__hash__ </code> function to the <code>Clause</code> class for it to be hashable. It is safe because <code>literals</code> shall not change after the formation of the clause.</p>
<pre><code class="language-python">@dataclass
class Clause:
    literals: List[Literal]

    def __repr__(self):
        return '∨'.join(map(str, self.literals))

    def __iter__(self) -&gt; Iterator[Literal]:
        return iter(self.literals)

    def __len__(self):
        return len(self.literals)

    def __hash__(self):
        x = 0 
        for lit in self.literals:
            x ^= hash(lit)
        return x
</code></pre>
<p>In the original CDCL algorithm, <code>unit_propagation</code> took most of the time, so the works of two watched literals lie most in <code>unit_propagation</code>.</p>
<p>You can run <code>python -m cProfile -s time cdcl.py cnf_file</code> to verify:</p>
<pre><code>         7405674 function calls (7404843 primitive calls) in 2.189 seconds

   Ordered by: internal time

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
   832445    1.217    0.000    1.903    0.000 full-cdcl.py:182(clause_status)
  1631505    0.262    0.000    0.262    0.000 full-cdcl.py:90(value)
      270    0.191    0.001    2.100    0.008 full-cdcl.py:209(unit_propagation)
  2417388    0.158    0.000    0.158    0.000 {method 'append' of 'list' objects}
   841475    0.150    0.000    0.212    0.000 full-cdcl.py:34(__iter__)
   842221    0.062    0.000    0.062    0.000 {built-in method builtins.iter}
   301638    0.036    0.000    0.036    0.000 {method 'count' of 'list' objects}
306672/306669    0.022    0.000    0.022    0.000 {built-in method builtins.len}
...
</code></pre>
<p>For each clause, we will try to watch two non-false literals. With the exception of unit clause, we watch the only non-false literals.</p>
<p>If a literal becomes <code>False</code>, we visit the clause that contains it. Note that if a literal becomes <code>True</code>, then its negation becomes <code>False</code>.</p>
<ul>
<li>
<p>First, we initialize the watches <code>clause2lits</code> and <code>lit2clauses</code> from the formula. </p>
</li>
<li>
<p>For each assignment, we put the assigned literal into a stack pending to propagate.</p>
</li>
<li>
<p>In <code>unit_propagate</code>, we pop off the literal <code>watching_lit</code> to propagate, try to rewatch <code>clause2lits[watching_lit]</code>, until conflict or the stack becomes empty.</p>
<p>In the figure below, if \(x_6\) is to be assign <code>False</code>, only 4 possible cases might arise.</p>
<p><img src="./images/The-2-watching-literal-method-The-watched-literals-are-are-x-6-and-x-8-Variable-x-6.png" alt="The 2-watching literal method. The watched literals are are x 6 and x 8...  | Download Scientific Diagram" /></p>
<ul>
<li>If we can find another non-false literal to rewatch, then rewatch it and all is fine. <em>(case 1)</em></li>
<li>If we cannot find another non-false literal to watch, and another watching literal is assigned <code>True</code>, then do nothing. <em>(case 2)</em></li>
<li>If we cannot find another non-false literal to watch, and another watching literal is unassigned, then the clause is unit, we assign it by unit rule and push it to the stack. <em>(case 3)</em></li>
<li>If we cannot find another non-false literal to watch, and another watching literal is assigned <code>False</code>, then a conflict occurs, do the backtrack. <em>(case 4)</em></li>
</ul>
</li>
</ul>
<pre><code class="language-python">def unit_propagation(assignments, lit2clauses, clause2lits, to_propagate: List[Literal]) -&gt; Tuple[str, Optional[Clause]]:
    while len(to_propagate) &gt; 0:
        watching_lit = to_propagate.pop().neg()

        # use list(.) to copy it because size of 
        # lit2clauses[watching_lit]might change during for-loop
        watching_clauses = list(lit2clauses[watching_lit])
        for watching_clause in watching_clauses:
            for lit in watching_clause:
                if lit in clause2lits[watching_clause]:
                    # lit is another watching literal of watching_clause
                    continue
                elif lit.variable in assignments and assignments.value(lit) == False:
                    # lit is a assigned False
                    continue
                else:
                    # lit is not another watching literal of watching_clause
                    # and is non-False literal, so we rewatch it. (case 1)
                    clause2lits[watching_clause].remove(watching_lit)
                    clause2lits[watching_clause].append(lit)
                    lit2clauses[watching_lit].remove(watching_clause)
                    lit2clauses[lit].append(watching_clause)
                    break
            else:
                # we cannot find another literal to rewatch (case 2,3,4)
                watching_lits = clause2lits[watching_clause]
                if len(watching_lits) == 1:
                    # watching_clause is unit clause, and the only literal
                    # is assigned False, thus indicates a conflict
                    return ('conflict', watching_clause)
               	
                # the other watching literal
                other = watching_lits[0] if watching_lits[1] == watching_lit else watching_lits[1]
                if other.variable not in assignments:
                    # the other watching literal is unassigned. (case 3)
                    assignments.assign(other.variable, not other.negation, watching_clause)
                    to_propagate.insert(0, other)
                elif assignments.value(other) == True:
                    # the other watching literal is assigned True. (case 2)
                    continue
                else:
                    # the other watching literal is assigned False. (case 4)
                    return ('conflict', watching_clause)

    return ('unresolved', None)
</code></pre>
<p>In the <code>add_learnt_clause</code>, we need to add the watches of the newly learnt clause, the literals to watch must be the most recent assigned literals (with largest decision level).</p>
<pre><code class="language-python">def add_learnt_clause(formula, clause, assignments, lit2clauses, clause2lits):
    formula.clauses.append(clause)
    for lit in sorted(clause, key=lambda lit: -assignments[lit.variable].dl):
        if len(clause2lits[clause]) &lt; 2:
            clause2lits[clause].append(lit)
            lit2clauses[lit].append(clause)
        else:
            break
</code></pre>
<p>Finally, the <code>cdcl_solve</code> function. We first initialize the watches and prepare the stack of literals to be propagated.</p>
<pre><code class="language-python">def cdcl_solve(formula: Formula) -&gt; Optional[Assignments]:
    &quot;&quot;&quot;
    Solve the CNF formula.

    If SAT, return the assignments.
    If UNSAT, return None.
    &quot;&quot;&quot;
    assignments = Assignments()
    lit2clauses, clause2lits = init_watches(formula)
    
    # First, do unit propagation to assign the initial unit clauses 
    unit_clauses = [clause for clause in formula if len(clause) == 1]
    to_propagate = []
    for clause in unit_clauses:
        lit = clause.literals[0]
        var = lit.variable
        val = not lit.negation
        if var not in assignments:
            assignments.assign(var, val, clause)
            to_propagate.append(lit)
    
    reason, clause = unit_propagation(assignments, lit2clauses, clause2lits, to_propagate)
    if reason == 'conflict':
        return None

    while not all_variables_assigned(formula, assignments):
        var, val = pick_branching_variable(formula, assignments)
        assignments.dl += 1
        assignments.assign(var, val, antecedent=None)
        to_propagate = [Literal(var, not val)]
        while True:
            reason, clause = unit_propagation(assignments, lit2clauses, clause2lits, to_propagate)
            if reason != 'conflict':
                # no conflict after unit propagation, we back
                # to the decision (guessing) step
                break
                
            b, learnt_clause = conflict_analysis(clause, assignments)
            if b &lt; 0:
                return None
            
            add_learnt_clause(formula, learnt_clause, assignments, lit2clauses, clause2lits)
            backtrack(assignments, b)
            assignments.dl = b

            # The learnt clause must be a unit clause, so the
            # next step must again be unit progagation
            literal = next(literal for literal in learnt_clause if literal.variable not in assignments)
            var = literal.variable
            val = not literal.negation
            assignments.assign(var, val, antecedent=learnt_clause)
            to_propagate = [Literal(var, not val)]

    return assignments
</code></pre>
<p>All is done!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h1>
<p>You shall compare the running times with and without the two-watched literals data structure. As I mentioned, the I did not put much attention on the code efficiency, you can easily speed up the running time a lot by refactoring the codes.</p>
<p>Further, incorporating a branching heuristic and restart heuristic can significantly improve the running speed on large CNF instances. Fortunately, all of them are not as complex and hard-to-debug as a [two-watched literals CDCL solver] alone.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </body>
</html>
